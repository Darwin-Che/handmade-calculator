#lang racket
(provide groupnum)

;; group together the numbers, chars including 1234567890.
;; using the Gen and cont style of programming



(define op-lst (list #\+ #\- #\* #\\))

(define (op? x) (if (boolean? (member x op-lst)) #false #true))

(define number-lst (list #\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9 #\.))

(define (Gen inp state step)
  (define (cont newinp state out)
     (append out (Gen (append newinp (cdr inp)) state step)))
  (step (if (empty? inp) empty (take inp 1)) state cont))

(define (my-step inp state cont)
  (if (empty? inp)
      (if (empty? state) empty
          (list (string->number (list->string (reverse state)))))
      (if (boolean? (member (car inp) number-lst))
          (if (empty? state)
              (cont empty empty (list (car inp)))
              (cont empty empty (list (string->number (list->string (reverse state))) (car inp))))
          (cont empty (cons (car inp) state) empty))))

(define (groupnum lst) (Gen (string->list lst) empty my-step))

;; check if it is a legal expression

;(define (check lst))

(define (brac? x) (or (eq? x #\() (eq? x #\))))
(define (bracl? x) (eq? x #\())
(define (bracr? x) (eq? x #\)))

;; 1. ( always followed by number/-
(define (check1 lst)
  (let ([tmp (member #\( lst)])
    (cond [(boolean? tmp) #true]
          [(empty? (cdr tmp)) (error "empty after (")]
          [(or (number? (cadr tmp)) (eq? #\- (cadr tmp)) (eq? #\+ (cadr tmp)) (eq? #\( (cadr tmp))) (check1 (cdr tmp))]
          [#true (error "incorrect use of (")])))
; (check1 (groupnum (read-line)))

;; 2. ) always followed by operation/empty
(define (check2 lst)
  (let ([tmp (member #\) lst)])
    (cond [(boolean? tmp) #true]
          [(or (empty? (cdr tmp)) (op? (cadr tmp)) (eq? #\) (cadr tmp))) (check2 (cdr tmp))]
          [#true (error "incorrect use of )")])))
; (check2 (groupnum (read-line)))

;; 3. operation always followed by (/number
(define (check3 lst)
  (let ([tmp (memf op? lst)])
    (cond [(boolean? tmp) #true]
          [(empty? (cdr tmp)) (error "empty after op")]
          [(or (number? (cadr tmp)) (eq? #\( (cadr tmp))) (check3 (cdr tmp))]
          [#true (error "incorrect use of op")])))
; (check3 (groupnum (read-line)))

;; 4. numbers always followed by operation/empty
(define (check4 lst)
  (let ([tmp (memf number? lst)])
    (cond [(boolean? tmp) #true]
          [(or (empty? (cdr tmp)) (op? (cadr tmp)) (eq? #\) (cadr tmp))) (check4 (cdr tmp))]
          [#true (error "incorrect use of num")])))
; (check4 (groupnum (read-line)))

;; 5. check brackets are corresponding, that is number of ( - number of ) >=0 for all, and =0 at end
(define (check5 lst i)
  (let ([tmp (memf brac? lst)])
    (cond [(< i 0) #false]
          [(boolean? tmp) (if (= i 0) #true (error "notequalbracs"))]
          [(bracl? (car tmp)) (check5 (cdr tmp) (add1 i))]
          [(bracr? (car tmp)) (check5 (cdr tmp) (sub1 i))]
          [#true (error "we are screwed")])))
; (check5 (groupnum (read-line)) 0)

(define-struct op-node (op left right))

; helper function
; 1. detect has brackets
; 2. get ()'s first appearence's index/ reverse index
; 3. concat lst forward/backward

(define (detect-brac lst) (not (boolean? (memf brac? lst))))

(define (get-first-brac lst)
  (define (help lst i)
    (if (empty? lst)
        (error "empty expression 2-1")
        (if (eq? (car lst) #\()
            i
            (help (cdr lst) (add1 i)))))
  (help lst 0))

(define (get-last-brac lst)
  (define (help lst i)
    (if (empty? lst)
        (error "empty expression 2-2")
        (if (eq? (car lst) #\))
            i
            (help (cdr lst) (add1 i)))))
  (help (reverse lst) 0))

(define (concat-before lst i)
  (if (= i -1)
      empty
      (cons (car lst) (concat-before (cdr lst) (sub1 i)))))

(define (concat-after lst i)
  (if (= i -1)
      lst
      (concat-after (cdr lst) (sub1 i))))

(define (concat-first lst i f) (f lst i))

(define (concat-last lst i f) (reverse (f (reverse lst) i)))

; 1. empty : return (error "empty lst")
; 2. one element : check if it is a number return number
; 3. has +/- : (+/- . (f out1) . (f out2))
; 4. has *// : (*// . (f out1) . (f out2))

(define (+/-? lst) (not (boolean? (memf (λ (x) (or (eq? #\+ x) (eq? #\- x))) lst))))
(define (*//? lst) (not (boolean? (memf (λ (x) (or (eq? #\* x) (eq? #\/ x))) lst))))

(define (cut-lst lst f)
  (define (help acc1 acc2)
    (if (empty? acc1)
        (error "empty acc1")
        (if (f (car acc1))
            (list (car acc1) acc2 (cdr acc1))
            (help (cdr acc1) (cons (car acc1) acc2)))))
  (help lst empty))

(define (list->tree lst)
  (cond [(empty? lst) (error "no expression")]
        [(empty? (cdr lst)) (if (number? (car lst)) (car lst) (error "not a number"))]
        [(+/-? lst)
         (let ([tmp (cut-lst lst (λ (x) (or (eq? #\+ x) (eq? #\- x))))])
           (make-op-node (first tmp) (list->tree (second tmp)) (list->tree (third tmp))))]
        [(*//? lst)
         (let ([tmp (cut-lst lst (λ (x) (or (eq? #\* x) (eq? #\/ x))))])
           (make-op-node (first tmp) (list->tree (second tmp)) (list->tree (third tmp))))]
        [#true (error "we are completely screwed")]))

(define (op-trans x)
  (cond [(eq? x #\+) (λ (a b) (+ a b))]
        [(eq? x #\-) (λ (a b) (- b a))]
        [(eq? x #\*) (λ (a b) (* a b))]
        [(eq? x #\/) (λ (a b) (/ b a))]
        [#true (error "some strange op-sign")]))

(define (calc-n node)
  (if (number? node)
      node
      ((op-trans (op-node-op node))
       (calc-n (op-node-left node))
       (calc-n (op-node-right node)))))

(define calc (λ () (calc-n (list->tree (reverse (groupnum (read-line)))))))

;(define x (reverse (groupnum (read-line))))
(calc)

